# Gestione Magazzino

## Sistema di Logistica Eterogenea

### Contesto

Stai sviluppando il backend per un grande centro di distribuzione (tipo Amazon). Il sistema deve gestire un catalogo misto di prodotti. Ogni tipo di prodotto ha caratteristiche uniche che devono essere preservate durante il salvataggio su disco (spegnimento del server) e ripristinate fedelmente al riavvio.

### Obiettivo

Creare un sistema che utilizzi una singola lista polimorfica per gestire diversi tipi di oggetti, serializzare questa lista su file e deserializzarla, verificando che il tipo specifico di ogni oggetto sia mantenuto.

### Requisiti Architetturali

#### 1. La Gerarchia delle Classi

Definisci una gerarchia di classi per rappresentare i prodotti:

- **Classe `Articolo`**:
  - Contiene campi comuni a tutti (es: `idUnivoco`, `nome`, `peso`).
  - Definisce un metodo (es: `stampaEtichetta()`) che le sottoclassi dovranno implementare.

- **Sottoclasse `TechGadget` (estende `Articolo`)**:
  - Rappresenta prodotti elettronici.
  - Aggiunge campi specifici come `batteriaInclusa` (boolean) e `marca`.

- **Sottoclasse `ProdottoFresco` (estende `Articolo`)**:
  - Rappresenta alimentari deperibili.
  - Aggiunge campi specifici come `temperaturaConservazione` (double) e `dataScadenza`.

#### 2. Il Gestore

Crea una classe `GestoreLogistica` che possiede:

- Un **unico** `ArrayList<Articolo>` che funge da database in memoria.
- Grazie al polimorfismo, questa lista dovr√† contenere istanze miste sia di `TechGadget` che di `ProdottoFresco`.

### Flusso dell'Esercizio

#### Fase A: Popolamento e Polimorfismo

Nel metodo `main`:

1. Istanzia il `GestoreLogistica`.
2. Aggiungi alla lista almeno 2 oggetti `TechGadget` e 2 oggetti `ProdottoFresco`.
3. Prima di serializzare, itera sulla lista e invoca il metodo `stampaEtichetta()` su ogni elemento. Osserva come ogni oggetto risponda in modo diverso in base alla propria classe (Polimorfismo).

#### Fase B: Serializzazione (Output)

Implementa un metodo che salvi l'intero `ArrayList<Articolo>` su un file (es. `database_logistica.dat`).

#### Fase C: Deserializzazione e Verifica (Input)

1. Svuota la lista in memoria o crea una nuova istanza del gestore.
2. Leggi il file e fai il casting del risultato in `ArrayList<Articolo>`.
3. **Il Test Cruciale:** Itera sulla lista appena caricata dal file:
   - Invoca di nuovo `stampaEtichetta()`.
   - Verifica che i dati specifici (es. la `temperaturaConservazione` per i freschi o la `marca` per i gadget) siano stati recuperati correttamente.
   - Usa l'operatore `instanceof` per contare quanti prodotti sono tecnologici e quanti sono freschi, dimostrando che il sistema riconosce ancora le classi originali dopo il caricamento.

---

### üî• Challenge Bonus (Facoltativo)

Per rendere l'esercizio ancora pi√π realistico, aggiungi queste complessit√†:

1. **Campo `transient`**: Aggiungi alla classe astratta `Articolo` un campo `codiceSessione` (un identificativo temporaneo valido solo mentre il programma gira).
   - Marcato come `transient`, questo campo non deve essere salvato.
   - Verifica che, dopo la deserializzazione, questo campo sia `null`.

2. **Campo `static`**: Aggiungi un contatore statico `numeroTotaleArticoli` nella classe `Articolo` che si incrementa nel costruttore.
   - Osserva cosa succede al contatore quando deserializzi gli oggetti. Il valore statico viene salvato nel file o dipende dallo stato attuale della JVM? (Questa √® una classica domanda da colloquio).
