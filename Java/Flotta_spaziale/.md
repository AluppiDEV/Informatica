üöÄ Esercizio: Gestione Flotta Spaziale "Astra"
Contesto
Sei un ingegnere software per la corporazione "Astra Logistics" e devi sviluppare il sistema di gestione della flotta. Il sistema deve catalogare diverse navi spaziali, gestire le missioni di trasporto e assegnare la nave "ottimale" a ciascuna missione, bilanciando capacit√†, sicurezza e costi operativi.

Obiettivi Didattici
Ereditariet√† e Classi Astratte: Definire una NaveSpaziale generica e specializzarla in NaveDaCarico e IncrociatoreDaBattaglia.

Composizione: Una Missione "contiene" un ArrayList di Container. Una StazioneSpaziale "contiene" un ArrayList di NaveSpaziale.

ArrayList: Usare ArrayList per la flotta e per il carico delle missioni.

Metodi Complessi: Implementare una logica di ottimizzazione per trovare la nave migliore per una missione, usando il polimorfismo.

üì¶ Classe 1: Container (Classe Semplice)
Una semplice classe "POJO" che rappresenta un'unit√† di carico.

Attributi:

String idContainer

double pesoTonnellate

boolean materialePericoloso (se true, richiede una nave pi√π sicura)

Metodi:

Costruttore e Getters.

üìú Classe 2: Missione (Composizione)
Rappresenta un contratto di trasporto. "Ha" una lista di container.

Attributi:

String idMissione

String destinazione (es. "Settore Kepler-186f")

int livelloPericoloSettore (un valore da 1 a 10, indica quanto √® pericolosa la rotta)

ArrayList<Container> caricoDellaMissione (inizializzato nel costruttore)

Metodi:

Costruttore.

void aggiungiContainer(Container c)

double getPesoTotale(): Metodo complesso (Iterazione). Ittera sull'ArrayList e somma i pesi.

boolean isMissionePericolosa(): Restituisce true se livelloPericoloSettore > 5 O se almeno uno dei container nel carico ha materialePericoloso == true.

üõ∞Ô∏è Classe 3: NaveSpaziale (Classe Astratta)
Rappresenta una nave generica della flotta. Non pu√≤ essere istanziata.

Attributi:

String idRegistrazione

double capacitaMassimaStiva (in tonnellate)

StatoNave stato (vedi Sotto-compito 1)

Metodi:

Costruttore e Getters.

void setStato(StatoNave nuovoStato)

boolean puoTrasportare(double pesoRichiesto): Metodo concreto. Controlla se pesoRichiesto <= capacitaMassimaStiva.

abstract boolean requisitiSicurezzaSoddisfatti(Missione m): Metodo astratto. Controlla se la nave √® adatta al pericolo della missione (dipende dal tipo di nave).

abstract double calcolaCostoOperativo(Missione m): Metodo astratto. Calcola il costo (in crediti) per eseguire quella missione specifica.

(Sotto-compito 1: Enum StatoNave)
Crea un enum chiamato StatoNave con i seguenti valori:

DISPONIBILE

IN_MISSIONE

IN_MANUTENZIONE

freighter Classe 4: NaveDaCarico (Concreta)
Specializzata per il trasporto sicuro, ma non per il combattimento.

Eredita da: NaveSpaziale

Attributi Aggiuntivi:

boolean stivaSchermata (se true, pu√≤ trasportare materialePericoloso senza rischi aggiuntivi)

Metodi:

Costruttore (che chiama super())

Implementazione di requisitiSicurezzaSoddisfatti(Missione m):

Restituisce false se m.getLivelloPericoloSettore() > 5 (non √® una nave da battaglia).

Restituisce false se m.isMissionePericolosa() (a causa del carico) E this.stivaSchermata == false.

Restituisce true in tutti gli altri casi.

Implementazione di calcolaCostoOperativo(Missione m):

Logica: (costoBaseCarburante * m.getPesoTotale()). (Es. 10 * m.getPesoTotale()).

üí• Classe 5: IncrociatoreDaBattaglia (Concreta)
Veloce, armata, costosa. Pu√≤ trasportare carico, ma non √® il suo scopo primario.

Eredita da: NaveSpaziale

Attributi Aggiuntivi:

int potenzaScudi (un valore da 1 a 10)

int numeroCannoniLaser

Metodi:

Costruttore (che chiama super())

Implementazione di requisitiSicurezzaSoddisfatti(Missione m):

Restituisce false se this.potenzaScudi < m.getLivelloPericoloSettore() (non √® abbastanza forte per quella rotta).

(Non si preoccupa del materialePericoloso, la stiva √® gi√† corazzata di default).

Restituisce true in tutti gli altri casi.

Implementazione di calcolaCostoOperativo(Missione m):

Logica: costoFissoEquipaggio (es. 5000 crediti) + (costoBaseCarburante * m.getPesoTotale() * 1.5) (consuma di pi√π).

üåå Classe 6: StazioneSpaziale (Classe Principale)
Gestisce la flotta e le missioni.

Attributi:

String nomeStazione (es. "Deep Space 9")

ArrayList<NaveSpaziale> flottaDisponibile

ArrayList<Missione> missioniInAttesa

Metodi:

Costruttore (inizializza gli ArrayList)

void aggiungiNaveAFlotta(NaveSpaziale n)

void aggiungiMissione(Missione m)

üß† Metodo Complesso da Implementare:
public NaveSpaziale assegnaNaveOttimale(Missione missione)

Questo √® il cuore del sistema. Deve trovare e assegnare la nave migliore per una data missione, rimuovendola da missioniInAttesa.

Logica:

Ottenere il pesoTotale dalla missione.

Creare una lista temporanea ArrayList<NaveSpaziale> naviCandidate.

Iterare sull'intera flottaDisponibile:

Per ogni nave:

Filtro 1 (Stato): Ignora la nave se il suo stato non √® DISPONIBILE.

Filtro 2 (Capacit√†): Ignora la nave se nave.puoTrasportare(pesoTotale) √® false.

Filtro 3 (Sicurezza - Polimorfismo!): Ignora la nave se nave.requisitiSicurezzaSoddisfatti(missione) √® false.

Se la nave passa tutti i filtri, aggiungila a naviCandidate.

Ottimizzazione:

Se naviCandidate √® vuota, la missione non pu√≤ essere assegnata. Stampa un messaggio e restituisci null.

Se ci sono candidate, itera su naviCandidate e trova quella che ha il costo operativo pi√π basso.

Per farlo, chiama nave.calcolaCostoOperativo(missione) su ciascuna candidata (il metodo corretto verr√† chiamato polimorficamente) e tieni traccia di quella con il costo minimo.

Assegnazione:

Prendi la naveMigliore trovata.

Imposta il suo stato a IN_MISSIONE.

Rimuovi la missione dall'ArrayList missioniInAttesa.

Restituisci naveMigliore.

üöÄ Compito
Implementare tutte le classi, l'enum StatoNave e i metodi descritti.

Scrivere il codice per i metodi di "calcolo" (getPesoTotale, isMissionePericolosa).

Implementare la logica complessa di filtraggio e ottimizzazione nel metodo assegnaNaveOttimale.

Creare una classe Main (Test) per simulare lo scenario:

Crea una StazioneSpaziale.

Crea 2 NaveDaCarico (una con stiva schermata, una no) e 1 IncrociatoreDaBattaglia. Aggiungili alla flotta.

Crea una Missione "facile" (poco peso, livelloPericolo = 2, nessun materiale pericoloso).

Crea una Missione "pericolosa" (poco peso, livelloPericolo = 8).

Crea una Missione "materiale speciale" (peso medio, livelloPericolo = 2, ma con materialePericoloso = true).

Chiama stazione.assegnaNaveOttimale() per ognuna delle tre missioni e stampa l'ID della nave assegnata (dovresti vedere la NaveDaCarico vincere la prima, l'Incrociatore la seconda, e la NaveDaCarico schermata la terza).